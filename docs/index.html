<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Feldbrugge &amp; Hidding" />
  <title>Caustic skeleton of 3D gradient deformation fields</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- Bootstrap 4.5.0 stylesheet -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="css/mods.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<!-- <script data-main="scripts/main" src="js/require.js"></script> -->
  <!-- Load React. -->
  <!-- Note: when deploying, replace "development.js" with "production.min.js". -->
<!--  <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script> -->


</head>
<body class="d-flex flex-column">

<nav id="TOC" class="navbar navbar-dark bg-dark">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a href="#" class="ml-5 mr-auto navbar-brand">Caustic skeleton of 3D gradient deformation fields<br><span style="font-size: smaller"> 
        by <i>Feldbrugge &amp; Hidding</i></span></a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul>
<li><a href="#singularities">Singularities</a></li>
<li><a href="#numeric-methods">Numeric methods</a></li>
<li><a href="#cosmology">Cosmology</a></li>
<li><a href="#marching-tetrahedra-1">Marching Tetrahedra</a></li>
</ul>
</div>
</nav>

<!-- <nav class="navbar navbar-dark navbar-expand-md bg-dark mb-4">
<p class="author">Feldbrugge &amp; Hidding</p>
</nav>
 -->

<main role="main" class="flex-fill"><div class="container my-5">
<p><span class="math display">\[
% LaTeX definitions
\renewcommand{\vec}[1]{{\bf #1}}
\newcommand{\grad}{\vec{\nabla}}
\]</span></p>
<p>Lagrangian map:</p>
<p><span class="math display">\[\vec{x}(t) = \vec{q} + D \vec{v}(D).\]</span></p>
<p>Hessian:</p>
<p><span class="math display">\[H_{ij} = \frac{\partial v_i}{\partial x_j}.\]</span></p>
<p>We have eigenvalues <span class="math inline">\(\alpha \le \beta \le \gamma\)</span> and corresponding eigenvectors <span class="math inline">\(v_{\alpha}\)</span>, <span class="math inline">\(v_{\beta}\)</span>, <span class="math inline">\(v_{\gamma}\)</span>. Alternatively we may write <span class="math inline">\(\lambda_1 \dots \lambda_3\)</span> and <span class="math inline">\(v_1 \dots v_3\)</span>.</p>
<h1 id="singularities">Singularities</h1>
<p><span class="math inline">\(A_2\)</span> or fold singularities can be found where <span class="math inline">\(D = 1/\lambda_i\)</span>.</p>
<p><span class="math inline">\(A_3\)</span> or cusp singularities can be found where <span class="math inline">\(v_i \cdot \grad \lambda_i = 0.\)</span></p>
<p>We know how to find these in 2D from Hidding 2014, which can be extended to 3D.</p>
<h1 id="numeric-methods">Numeric methods</h1>
<p>We assume the values of the Hessian are known at grid points. By means of interpolation we can compute continuous functional representations of the eigenvalue and eigenvector fields.</p>
<p>Each cube on the grid is divided into six tetrahedra. To compute <span class="math inline">\(A_2\)</span> singularities we want to extract the level set for <span class="math inline">\(\lambda_i = 1/D\)</span>. We use marching tetrahedra algorithm on the interpolated eigenvalue function. This gives us a guaranteed manifold with correct structure (i.e. no boundary).</p>
<h2 id="marching-tetrahedra">Marching tetrahedra</h2>
<p>Given a tetrahedron we may find the species of resulting triangle by comparing vertex values to the iso contour level, where earch vertex is assigned a bit (e.g. 0 for smaller than x, 1 for larger or equal to x), resulting in one of 16 possible geometries, ranging from empty, to triangle or quadrilangle. Due to symmetry only 8 unique cases arise.</p>
<p>First <span class="math inline">\(A_2\)</span> is computed for each tetrahedron separately, then the intersection of <span class="math inline">\(A_3\)</span> surfaces with <span class="math inline">\(A_2\)</span> can be computed for that specific time <span class="math inline">\(D\)</span>.</p>
<p>In a similar way we can compute the entire <span class="math inline">\(D_3\)</span> surface (the bigcaustic), and recursively <span class="math inline">\(A_4\)</span> lines are found on this surface, and <span class="math inline">\(A_5\)</span> on the <span class="math inline">\(A_4\)</span> lines. For each step in this cascade we have the following constraints:</p>
<table>
<thead>
<tr class="header">
<th>caustic</th>
<th>constraint</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(A_3\)</span></td>
<td><span class="math inline">\(v_i \cdot \grad \lambda_i = 0\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(A_4\)</span></td>
<td><span class="math inline">\(v_i \cdot \grad (v_i \cdot \grad \lambda_i) = 0\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(A_5\)</span></td>
<td><span class="math inline">\(v_i \cdot \grad (v_i \cdot \grad (v_i \cdot \lambda_i)) = 0\)</span></td>
</tr>
</tbody>
</table>
<h2 id="d_4"><span class="math inline">\(D_4\)</span></h2>
<p>This is the hard one. Feldbrugge (eq 4.15-17) derived a set of conditions which we can use to detect those places where <span class="math display">\[\alpha = \beta\quad {\rm or}\quad \beta = \gamma.\]</span> To remind ourselves, why is this so hard? We have methods of computing the eigenvalues such that <span class="math inline">\(\alpha \ge \beta \ge \gamma\)</span>. We used Cardano’s formula on the characteristic equation of the Hessian to find these. It is not possible however, to find a good continuous representation where these fields are disambiguated such that we can compute the level set of say (<span class="math inline">\(\alpha - \beta\)</span>). To understand this we should learn about the geometry of the eigenvalue fields: near points where we expect <span class="math inline">\(\alpha = \beta\)</span>, on a 2D domain these fields assume the shape of a cone. From generic fields with transverse crossings we would expect these to intersect in a line, however, we find only points. In 3D the equation <span class="math inline">\(\alpha = \beta\)</span> yields curves, again one dimension less than we would expect from a naive level set. We need to expand the condition to a set of at least two conditions, to arrive at curves.</p>
<p><span class="math display">\[\begin{align}
C_1: &amp;H_{11} H_{13} H_{23} + H_{12} H_{23}^2 = H_{22} H_{13} H_{23} + H_{12} H_{13}^2\\
C_2: &amp;H_{22} H_{12} H_{13} + H_{23} H_{13}^2 = H_{33} H_{12} H_{13} + H_{23} H_{12}^2\\
C_3: &amp;H_{33} H_{23} H_{12} + H_{13} H_{12}^2 = H_{11} H_{23} H_{12} + H_{13} H_{23}^2
\end{align}\]</span></p>
<p>Two of these conditions suffice to compute the <span class="math inline">\(D_4\)</span> singularities, but where they differ is in their numerical stability. If say <span class="math inline">\(H_{12}\)</span> is large compared to <span class="math inline">\(H_{13}\)</span> and <span class="math inline">\(H_{23}\)</span>, it makes more sense to use <span class="math inline">\(C_2\)</span> and <span class="math inline">\(C_3\)</span> over <span class="math inline">\(C_1\)</span>. Note that the relations are completely cyclic.</p>
<h1 id="cosmology">Cosmology</h1>
<p>For our cosmology we only consider <span class="math inline">\(h\)</span>, <span class="math inline">\(\Omega_m\)</span> and <span class="math inline">\(\Omega_{\Lambda}\)</span> as parameters.</p>
<div class="annotated-code">
<p><span><em>«cosmology-parameters»=</em></span></p>
<div class="sourceCode" id="cosmology-parameters"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cosmology-parameters-1"><a href="#cosmology-parameters-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cosmology-parameters-2"><a href="#cosmology-parameters-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Cosmology <span class="op">{</span></span>
<span id="cosmology-parameters-3"><a href="#cosmology-parameters-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> h<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cosmology-parameters-4"><a href="#cosmology-parameters-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> omega_m<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cosmology-parameters-5"><a href="#cosmology-parameters-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> omega_l<span class="op">:</span> <span class="dt">f64</span></span>
<span id="cosmology-parameters-6"><a href="#cosmology-parameters-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The Friedman equation for such a universe is as follows,</p>
<p><span class="math display">\[\left(\frac{H}{H_0}\right)^2 = \Omega_m a^{-3} + (1 - \Omega_m - \Omega_{\Lambda}) a^{-2} + \Omega_{\Lambda}.\]</span></p>
<div class="annotated-code">
<p><span><em>«friedman-equation»=</em></span></p>
<div class="sourceCode" id="friedman-equation"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="friedman-equation-1"><a href="#friedman-equation-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> friedman_eqn(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="friedman-equation-2"><a href="#friedman-equation-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">self</span><span class="op">.</span>omega_m <span class="op">*</span> a<span class="op">.</span>powf(<span class="op">-</span><span class="dv">3.0</span>) <span class="op">+</span> (<span class="dv">1.0</span> <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>omega_m <span class="op">-</span> <span class="kw">self</span><span class="op">.</span>omega_l) <span class="op">*</span> a<span class="op">.</span>powf(<span class="op">-</span><span class="dv">2.0</span>) <span class="op">+</span> <span class="kw">self</span><span class="op">.</span>omega_l</span>
<span id="friedman-equation-3"><a href="#friedman-equation-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>For Einstein-de Sitter or concordance universes this equation suffices to compute the function <span class="math inline">\(a(t)\)</span>, the scale factor as a function of time in seconds.</p>
<div class="annotated-code">
<p><span><em>«scale-factor-da»=</em></span></p>
<div class="sourceCode" id="scale-factor-da"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="scale-factor-da-1"><a href="#scale-factor-da-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> da(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="scale-factor-da-2"><a href="#scale-factor-da-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">self</span><span class="op">.</span>friedman_eqn(a)<span class="op">.</span>sqrt() <span class="op">*</span> <span class="dv">100.0</span> <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>h <span class="op">*</span> a <span class="op">*</span> KM_PER_MPC</span>
<span id="scale-factor-da-3"><a href="#scale-factor-da-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Because the resulting equation explodes for small <span class="math inline">\(a\)</span>, we need to use an approximation there. When <span class="math inline">\(a\)</span> is small, the term with <span class="math inline">\(a^{-3}\)</span> dominates. The equation for a matter-dominated universe can be directly solved using an ansatz of <span class="math inline">\(a \sim t^n\)</span>. We arrive at the limiting case,</p>
<p><span class="math display">\[a_{\rm matter}(t) = \left(\frac{3}{2} \sqrt{\Omega_m} H_0 t\right)^{2/3}.\]</span></p>
<div class="annotated-code">
<p><span><em>«scale-factor-limit»=</em></span></p>
<div class="sourceCode" id="scale-factor-limit"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="scale-factor-limit-1"><a href="#scale-factor-limit-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> limit_a(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> t<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="scale-factor-limit-2"><a href="#scale-factor-limit-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">self</span><span class="op">.</span>omega_m<span class="op">.</span>sqrt() <span class="op">*</span> <span class="dv">3.0</span> <span class="op">*</span> t <span class="op">*</span> <span class="dv">100.0</span> <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>h <span class="op">*</span> KM_PER_MPC <span class="op">/</span> <span class="dv">2.0</span>)<span class="op">.</span>powf(<span class="dv">2.0</span><span class="op">/</span><span class="dv">3.0</span>)</span>
<span id="scale-factor-limit-3"><a href="#scale-factor-limit-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="scale-factor-limit-4"><a href="#scale-factor-limit-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="scale-factor-limit-5"><a href="#scale-factor-limit-5" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="scale-factor-limit-6"><a href="#scale-factor-limit-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> limit_t(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="scale-factor-limit-7"><a href="#scale-factor-limit-7" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>powf(<span class="dv">3.0</span> <span class="op">/</span> <span class="dv">2.0</span>) <span class="op">*</span> <span class="dv">2.0</span> <span class="op">/</span> (<span class="kw">self</span><span class="op">.</span>omega_m<span class="op">.</span>sqrt() <span class="op">*</span> <span class="dv">3.0</span> <span class="op">*</span> <span class="dv">100.0</span> <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>h <span class="op">*</span> KM_PER_MPC)</span>
<span id="scale-factor-limit-8"><a href="#scale-factor-limit-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h2 id="growing-mode-solution">Growing mode solution</h2>
<p>The growing-mode solution <span class="math inline">\(D\)</span> can be computed as function of the scale factor <span class="math inline">\(a\)</span> using the integral expression,</p>
<p><span class="math display">\[D(a) \propto \frac{\dot{a}}{a} \int_0^a \frac{{\rm d}a&#39;}{\dot{a}&#39;^3}.\]</span></p>
<p>In the limit of small <span class="math inline">\(a\)</span> we may choose to have <span class="math inline">\(D(a) = a\)</span>, adding a factor <span class="math inline">\(\frac{5}{2} H_0^2 \Omega_m\)</span>. In doing this, we may drop all factors of <span class="math inline">\(H_0\)</span> from the computation.</p>
<div class="annotated-code">
<p><span><em>«growing-mode»=</em></span></p>
<div class="sourceCode" id="growing-mode"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="growing-mode-1"><a href="#growing-mode-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> growing_mode(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="growing-mode-2"><a href="#growing-mode-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> integrant <span class="op">=</span> <span class="op">|</span>a<span class="op">|</span> <span class="op">{</span></span>
<span id="growing-mode-3"><a href="#growing-mode-3" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">self</span><span class="op">.</span>friedman_eqn(a)<span class="op">.</span>sqrt() <span class="op">*</span> a)<span class="op">.</span>powf(<span class="op">-</span><span class="dv">3.0</span>)</span>
<span id="growing-mode-4"><a href="#growing-mode-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="growing-mode-5"><a href="#growing-mode-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="growing-mode-6"><a href="#growing-mode-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> A_SMALL<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">0.001</span><span class="op">;</span></span>
<span id="growing-mode-7"><a href="#growing-mode-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&lt;</span> A_SMALL <span class="op">{</span></span>
<span id="growing-mode-8"><a href="#growing-mode-8" aria-hidden="true" tabindex="-1"></a>        a</span>
<span id="growing-mode-9"><a href="#growing-mode-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="growing-mode-10"><a href="#growing-mode-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> int_init  <span class="op">=</span> <span class="dv">0.4</span> <span class="op">*</span> A_SMALL<span class="op">.</span>powf(<span class="dv">2.5</span>) <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>omega_m<span class="op">.</span>powf(<span class="op">-</span><span class="dv">1.5</span>)<span class="op">;</span></span>
<span id="growing-mode-11"><a href="#growing-mode-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (int_rest<span class="op">,</span> _<span class="op">,</span> _<span class="op">,</span> _) <span class="op">=</span> <span class="pp">rgsl::integration::</span>qk15(integrant<span class="op">,</span> A_SMALL<span class="op">,</span> a)<span class="op">;</span></span>
<span id="growing-mode-12"><a href="#growing-mode-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> hubble_factor <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>friedman_eqn(a)<span class="op">.</span>sqrt()<span class="op">;</span></span>
<span id="growing-mode-13"><a href="#growing-mode-13" aria-hidden="true" tabindex="-1"></a>        (int_init <span class="op">+</span> int_rest) <span class="op">*</span> hubble_factor <span class="op">*</span> <span class="dv">2.5</span> <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>omega_m</span>
<span id="growing-mode-14"><a href="#growing-mode-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="growing-mode-15"><a href="#growing-mode-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h2 id="tests">Tests</h2>
<div class="annotated-code">
<p><span><em>«src/cosmology.rs»=</em></span></p>
<div class="sourceCode" id="cb1" data-file="src/cosmology.rs"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> rgsl<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> KM_PER_MPC<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">3.24077929e-20</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> SEC_PER_GYR<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">3.15576e16</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>cosmology<span class="op">-</span>parameters<span class="op">&gt;&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> PLANCK_COSMOLOGY<span class="op">:</span> Cosmology <span class="op">=</span> Cosmology <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    h<span class="op">:</span> <span class="dv">0.678</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    omega_m<span class="op">:</span> <span class="dv">0.308</span><span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    omega_l<span class="op">:</span> <span class="dv">0.692</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">const</span> EDS_COSMOLOGY<span class="op">:</span> Cosmology <span class="op">=</span> Cosmology <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    h<span class="op">:</span> <span class="dv">0.7</span><span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    omega_m<span class="op">:</span> <span class="dv">1.0</span><span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    omega_l<span class="op">:</span> <span class="dv">0.0</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> euler_method<span class="op">&lt;</span>F1<span class="op">,</span> Pred<span class="op">&gt;</span>(dy<span class="op">:</span> F1<span class="op">,</span> t0<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> y0<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> dt<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> stop<span class="op">:</span> Pred) <span class="op">-&gt;</span> (<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> F1<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>          Pred<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">f64</span><span class="op">,</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">bool</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> t <span class="op">=</span> t0<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> y <span class="op">=</span> y0<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">!</span>stop(t<span class="op">,</span> y) <span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        y <span class="op">+=</span> dt <span class="op">*</span> dy(y)<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        t <span class="op">+=</span> dt<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    (t<span class="op">,</span> y)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Cosmology <span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>friedman<span class="op">-</span>equation<span class="op">&gt;&gt;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>scale<span class="op">-</span>factor<span class="op">-</span>da<span class="op">&gt;&gt;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>scale<span class="op">-</span>factor<span class="op">-</span>limit<span class="op">&gt;&gt;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>growing<span class="op">-</span>mode<span class="op">&gt;&gt;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> t0(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> t0 <span class="op">=</span> <span class="dv">0.01</span> <span class="op">*</span> SEC_PER_GYR<span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> dt <span class="op">=</span> <span class="dv">0.01</span> <span class="op">*</span> SEC_PER_GYR<span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a0 <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>limit_a(t0)<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (age<span class="op">,</span> _) <span class="op">=</span> euler_method(</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span>a<span class="op">|</span> <span class="kw">self</span><span class="op">.</span>da(a)<span class="op">,</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            t0<span class="op">,</span> a0<span class="op">,</span> dt<span class="op">,</span> <span class="op">|</span>_<span class="op">,</span> a<span class="op">|</span> <span class="op">{</span> a <span class="op">&gt;=</span> <span class="dv">1.0</span> <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        age</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">assert_approx_eq::</span>assert_approx_eq<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test_age_of_universe() <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_approx_eq!</span>(PLANCK_COSMOLOGY<span class="op">.</span>t0() <span class="op">/</span> SEC_PER_GYR<span class="op">,</span> <span class="dv">13.8</span><span class="op">,</span> <span class="dv">0.1</span>)<span class="op">;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test_limit_fn() <span class="op">{</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> t0 <span class="op">=</span> <span class="dv">0.01</span><span class="op">;</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a0 <span class="op">=</span> PLANCK_COSMOLOGY<span class="op">.</span>limit_a(t0)<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_approx_eq!</span>(t0<span class="op">,</span> PLANCK_COSMOLOGY<span class="op">.</span>limit_t(a0)<span class="op">,</span> <span class="dv">1e-6</span>)<span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h1 id="marching-tetrahedra-1">Marching Tetrahedra</h1>
<p>What do we need? An oracle!</p>
<div class="annotated-code">
<p><span><em>«oracle-trait»=</em></span></p>
<div class="sourceCode" id="oracle-trait"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="oracle-trait-1"><a href="#oracle-trait-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Oracle <span class="op">{</span></span>
<span id="oracle-trait-2"><a href="#oracle-trait-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Elem<span class="op">;</span></span>
<span id="oracle-trait-3"><a href="#oracle-trait-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> grid_shape(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="oracle-trait-4"><a href="#oracle-trait-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> stencil(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> x<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> [<span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">;</span><span class="dv">8</span>]<span class="op">;</span></span>
<span id="oracle-trait-5"><a href="#oracle-trait-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> intersect(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> b<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Vec3<span class="op">&gt;;</span></span>
<span id="oracle-trait-6"><a href="#oracle-trait-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>The oracle provides a grid shape, a way of extracting a voxel (also known as <strong>stenciling</strong>) and a way of finding a intersection given two grid points. We have a separate function that detects if an edge intersects the surface or not and a function to compute that intersection, chiefly because computing the intersection might be an expensive operation.</p>
<p>If we are looking at an orientable manifold (essentially that means: no edges and a well defined inside/outside), all the information we need is wether a point lies <em>inside</em> or <em>outside</em>.</p>
<blockquote>
<p>We call this trait <code>Manifold</code>, though I’m not sure if it is possible to define something for non-orientable manifolds: to compute the surface of, say a Klein bottle implicitely, is that even possible within this <code>Oracle</code> architecture? We would need a stratified array as input, the stencil returning a tuple of floats (one for each stratum), but <code>intersect</code> would need to be fed the stratum as an extra argument. In each stratum the surface would no longer be manifold, since there are edges where the surface moves between strata.</p>
</blockquote>
<div class="annotated-code">
<p><span><em>«manifold-trait»=</em></span></p>
<div class="sourceCode" id="manifold-trait"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="manifold-trait-1"><a href="#manifold-trait-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Manifold<span class="op">:</span> Oracle <span class="kw">where</span> <span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">:</span> <span class="bu">Copy</span> <span class="op">{</span></span>
<span id="manifold-trait-2"><a href="#manifold-trait-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> point_inside(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> x<span class="op">:</span> <span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">,</span> level<span class="op">:</span> <span class="dt">Self</span><span class="pp">::</span>Elem) <span class="op">-&gt;</span> <span class="dt">bool</span><span class="op">;</span></span>
<span id="manifold-trait-3"><a href="#manifold-trait-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>manifold<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span>
<span id="manifold-trait-4"><a href="#manifold-trait-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">&gt;&gt;</span></span>
<span id="manifold-trait-5"><a href="#manifold-trait-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Each voxel is subdivided into six tetrahedra. There are many ways to do this, but the choice should be such that edges of neighbouring voxels line up. We number the corners of a voxel following a binary indexing scheme: <span class="math inline">\(0 \to (0,0,0)\)</span>, <span class="math inline">\(1 \to (0,0,1)\)</span>, <span class="math inline">\(2 \to (0,1,0)\)</span> etc. One way to achieve this is first drawing a diagonal and then have all tetrahedra include the diagonal edge. Within this logic, we can define any edge within the voxel as a pair of two integers.</p>
<div class="annotated-code">
<p><span><em>«cube-decomposition»=</em></span></p>
<div class="sourceCode" id="cube-decomposition"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cube-decomposition-1"><a href="#cube-decomposition-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> VoxelEdge <span class="op">=</span> (<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">;</span></span>
<span id="cube-decomposition-2"><a href="#cube-decomposition-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cube-decomposition-3"><a href="#cube-decomposition-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> CUBE_CELLS<span class="op">:</span> [[<span class="dt">usize</span><span class="op">;</span><span class="dv">4</span>]<span class="op">;</span><span class="dv">6</span>] <span class="op">=</span></span>
<span id="cube-decomposition-4"><a href="#cube-decomposition-4" aria-hidden="true" tabindex="-1"></a>    [ [ <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span> ]</span>
<span id="cube-decomposition-5"><a href="#cube-decomposition-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> [ <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span> ]</span>
<span id="cube-decomposition-6"><a href="#cube-decomposition-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> [ <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">5</span> ]</span>
<span id="cube-decomposition-7"><a href="#cube-decomposition-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> [ <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">5</span> ]</span>
<span id="cube-decomposition-8"><a href="#cube-decomposition-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> [ <span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span> ]</span>
<span id="cube-decomposition-9"><a href="#cube-decomposition-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">,</span> [ <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span> ] ]<span class="op">;</span></span></code></pre></div>
</div>
<p>Now for the algorithm, it is subdivided in a collection, combination and computation phase. From architectural point of view, it is not strictly needed to have the <code>level</code> as an argument to <code>level_set</code>; we could imagine the implementation of <code>point_inside</code> taking care of that. We have chosen this interface here to allow for the all to common use case of finding a level set of an <code>Array3&lt;f64&gt;</code> dataset. By keeping <code>level</code> outside the closure we can implement <code>Manifold</code> directly on the <code>Array3</code> type.</p>
<div class="annotated-code">
<p><span><em>«level-set»=</em></span></p>
<div class="sourceCode" id="level-set"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="level-set-1"><a href="#level-set-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> level_set(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> level<span class="op">:</span> <span class="dt">Self</span><span class="pp">::</span>Elem) <span class="op">-&gt;</span> Mesh <span class="op">{</span></span>
<span id="level-set-2"><a href="#level-set-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::collections::</span>BTreeMap<span class="op">;</span></span>
<span id="level-set-3"><a href="#level-set-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">-</span>collect<span class="op">&gt;&gt;</span></span>
<span id="level-set-4"><a href="#level-set-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">-</span>combine<span class="op">&gt;&gt;</span></span>
<span id="level-set-5"><a href="#level-set-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">-</span>compute<span class="op">&gt;&gt;</span></span>
<span id="level-set-6"><a href="#level-set-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>First we scan each voxel for any intersections. We don’t yet compute the actual location of the triangles, just the locations in the grid where there must be a triangle. Each proto-triangle consists of three proto-vertices, where a proto-vertex consists of two neighbouring grid points of which we know one is inside and the other outside. These proto-triangles can be found independently from each other.</p>
<div class="annotated-code">
<p><span><em>«marching-tetrahedra-types»=</em></span></p>
<div class="sourceCode" id="marching-tetrahedra-types"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="marching-tetrahedra-types-1"><a href="#marching-tetrahedra-types-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Loc <span class="op">=</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="marching-tetrahedra-types-2"><a href="#marching-tetrahedra-types-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ProtoVertex <span class="op">=</span> (Loc<span class="op">,</span> Loc)<span class="op">;</span></span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«level-set-collect»=</em></span></p>
<div class="sourceCode" id="level-set-collect"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="level-set-collect-1"><a href="#level-set-collect-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> proto_triangles <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span>[ProtoVertex<span class="op">;</span><span class="dv">3</span>]<span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="level-set-collect-2"><a href="#level-set-collect-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="level-set-collect-3"><a href="#level-set-collect-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ix <span class="kw">in</span> indices(<span class="kw">self</span><span class="op">.</span>grid_shape()) <span class="op">{</span></span>
<span id="level-set-collect-4"><a href="#level-set-collect-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> index <span class="op">=</span> [ix<span class="op">.</span><span class="dv">0</span><span class="op">,</span> ix<span class="op">.</span><span class="dv">1</span><span class="op">,</span> ix<span class="op">.</span><span class="dv">2</span>]<span class="op">;</span></span>
<span id="level-set-collect-5"><a href="#level-set-collect-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fx <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>stencil(index)<span class="op">;</span></span>
<span id="level-set-collect-6"><a href="#level-set-collect-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">self</span><span class="op">.</span>intersect_voxel(<span class="op">&amp;</span>fx<span class="op">,</span> level)<span class="op">.</span>iter()<span class="op">.</span>for_each(</span>
<span id="level-set-collect-7"><a href="#level-set-collect-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span>e<span class="op">|</span> proto_triangles<span class="op">.</span>push(offset_voxel_edge(<span class="kw">self</span><span class="op">.</span>grid_shape()<span class="op">,</span> index<span class="op">,</span> <span class="op">*</span>e)))<span class="op">;</span></span>
<span id="level-set-collect-8"><a href="#level-set-collect-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Here, we loop over every location in the grid. We extract a <span class="math inline">\(2 \times 2 \times 2\)</span> stencil, then scan this tiny area for proto-triangles. After we found the triangles within the voxel, we need to convert the voxel-local coordinates to grid coordinates.</p>
<div class="annotated-code">
<p><span><em>«marching-tetrahedra-utils»=</em></span></p>
<div class="sourceCode" id="marching-tetrahedra-utils"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="marching-tetrahedra-utils-1"><a href="#marching-tetrahedra-utils-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> offset_voxel_edge(shape<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> ix<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> et<span class="op">:</span> [VoxelEdge<span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> [ProtoVertex<span class="op">;</span><span class="dv">3</span>] <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-2"><a href="#marching-tetrahedra-utils-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> offset <span class="op">=</span> <span class="op">|</span>i<span class="op">:</span> <span class="dt">usize</span><span class="op">|</span> <span class="op">-&gt;</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>] <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-3"><a href="#marching-tetrahedra-utils-3" aria-hidden="true" tabindex="-1"></a>        [ (ix[<span class="dv">0</span>] <span class="op">+</span> ((i <span class="op">&amp;</span> <span class="dv">0x4</span>) <span class="op">&gt;&gt;</span> <span class="dv">2</span>)) <span class="op">%</span> shape[<span class="dv">0</span>]</span>
<span id="marching-tetrahedra-utils-4"><a href="#marching-tetrahedra-utils-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> (ix[<span class="dv">1</span>] <span class="op">+</span> ((i <span class="op">&amp;</span> <span class="dv">0x2</span>) <span class="op">&gt;&gt;</span> <span class="dv">1</span>)) <span class="op">%</span> shape[<span class="dv">1</span>]</span>
<span id="marching-tetrahedra-utils-5"><a href="#marching-tetrahedra-utils-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> (ix[<span class="dv">2</span>] <span class="op">+</span> ((i <span class="op">&amp;</span> <span class="dv">0x1</span>)     )) <span class="op">%</span> shape[<span class="dv">2</span>] ]</span>
<span id="marching-tetrahedra-utils-6"><a href="#marching-tetrahedra-utils-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="marching-tetrahedra-utils-7"><a href="#marching-tetrahedra-utils-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="marching-tetrahedra-utils-8"><a href="#marching-tetrahedra-utils-8" aria-hidden="true" tabindex="-1"></a>    et<span class="op">.</span>map(<span class="op">|</span>e<span class="op">|</span> (offset(e<span class="op">.</span><span class="dv">0</span>)<span class="op">,</span> offset(e<span class="op">.</span><span class="dv">1</span>)))</span>
<span id="marching-tetrahedra-utils-9"><a href="#marching-tetrahedra-utils-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Within the voxel we compute the traditional <strong>marching tetrahedra</strong> algorithm. Each vertex of the tetrahedron is checkout for inside/outside-ness, giving a number between 0 and 15. Depending on this pattern we can identify eight different cases, not looking at orientation of the triangle.</p>
<div class="annotated-code">
<p><span><em>«manifold-methods»=</em></span></p>
<div class="sourceCode" id="manifold-methods"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="manifold-methods-1"><a href="#manifold-methods-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect_tetrahedron(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> fx<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">;</span><span class="dv">8</span>]<span class="op">,</span> level<span class="op">:</span> <span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">,</span></span>
<span id="manifold-methods-2"><a href="#manifold-methods-2" aria-hidden="true" tabindex="-1"></a>                         vertices<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">usize</span><span class="op">;</span><span class="dv">4</span>]<span class="op">,</span> triangles<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span>[VoxelEdge<span class="op">;</span><span class="dv">3</span>]<span class="op">&gt;</span>)</span>
<span id="manifold-methods-3"><a href="#manifold-methods-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="manifold-methods-4"><a href="#manifold-methods-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> push_triangle <span class="op">=</span> <span class="op">|</span>a1<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> a2<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> b1<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> b2<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> c1<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> c2<span class="op">:</span> <span class="dt">usize</span><span class="op">|</span> <span class="op">{</span></span>
<span id="manifold-methods-5"><a href="#manifold-methods-5" aria-hidden="true" tabindex="-1"></a>        triangles<span class="op">.</span>push([ (vertices[a1]<span class="op">,</span> vertices[a2])</span>
<span id="manifold-methods-6"><a href="#manifold-methods-6" aria-hidden="true" tabindex="-1"></a>                       <span class="op">,</span> (vertices[b1]<span class="op">,</span> vertices[b2])</span>
<span id="manifold-methods-7"><a href="#manifold-methods-7" aria-hidden="true" tabindex="-1"></a>                       <span class="op">,</span> (vertices[c1]<span class="op">,</span> vertices[c2]) ])<span class="op">;</span></span>
<span id="manifold-methods-8"><a href="#manifold-methods-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="manifold-methods-9"><a href="#manifold-methods-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="manifold-methods-10"><a href="#manifold-methods-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> case<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">0x00</span><span class="op">;</span></span>
<span id="manifold-methods-11"><a href="#manifold-methods-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="manifold-methods-12"><a href="#manifold-methods-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>point_inside(fx[vertices[<span class="dv">0</span>]]<span class="op">,</span> level) <span class="op">{</span> case <span class="op">|=</span> <span class="dv">0x01</span><span class="op">;</span> <span class="op">}</span></span>
<span id="manifold-methods-13"><a href="#manifold-methods-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>point_inside(fx[vertices[<span class="dv">1</span>]]<span class="op">,</span> level) <span class="op">{</span> case <span class="op">|=</span> <span class="dv">0x02</span><span class="op">;</span> <span class="op">}</span></span>
<span id="manifold-methods-14"><a href="#manifold-methods-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>point_inside(fx[vertices[<span class="dv">2</span>]]<span class="op">,</span> level) <span class="op">{</span> case <span class="op">|=</span> <span class="dv">0x04</span><span class="op">;</span> <span class="op">}</span></span>
<span id="manifold-methods-15"><a href="#manifold-methods-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>point_inside(fx[vertices[<span class="dv">3</span>]]<span class="op">,</span> level) <span class="op">{</span> case <span class="op">|=</span> <span class="dv">0x08</span><span class="op">;</span> <span class="op">}</span></span>
<span id="manifold-methods-16"><a href="#manifold-methods-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="manifold-methods-17"><a href="#manifold-methods-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> case <span class="op">{</span></span>
<span id="manifold-methods-18"><a href="#manifold-methods-18" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x00</span> <span class="op">|</span> <span class="dv">0x0F</span> <span class="op">=&gt;</span> <span class="op">{},</span></span>
<span id="manifold-methods-19"><a href="#manifold-methods-19" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x01</span> <span class="op">|</span> <span class="dv">0x0E</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-20"><a href="#manifold-methods-20" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x02</span> <span class="op">|</span> <span class="dv">0x0D</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-21"><a href="#manifold-methods-21" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x03</span> <span class="op">|</span> <span class="dv">0x0C</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="manifold-methods-22"><a href="#manifold-methods-22" aria-hidden="true" tabindex="-1"></a>                         push_triangle(<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-23"><a href="#manifold-methods-23" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x04</span> <span class="op">|</span> <span class="dv">0x0B</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-24"><a href="#manifold-methods-24" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x05</span> <span class="op">|</span> <span class="dv">0x0A</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="manifold-methods-25"><a href="#manifold-methods-25" aria-hidden="true" tabindex="-1"></a>                         push_triangle(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-26"><a href="#manifold-methods-26" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x06</span> <span class="op">|</span> <span class="dv">0x09</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span> </span>
<span id="manifold-methods-27"><a href="#manifold-methods-27" aria-hidden="true" tabindex="-1"></a>                         push_triangle(<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-28"><a href="#manifold-methods-28" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x07</span> <span class="op">|</span> <span class="dv">0x08</span> <span class="op">=&gt;</span> <span class="op">{</span> push_triangle(<span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span> <span class="op">},</span></span>
<span id="manifold-methods-29"><a href="#manifold-methods-29" aria-hidden="true" tabindex="-1"></a>        _           <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;system error&quot;</span>)</span>
<span id="manifold-methods-30"><a href="#manifold-methods-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="manifold-methods-31"><a href="#manifold-methods-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="manifold-methods-32"><a href="#manifold-methods-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="manifold-methods-33"><a href="#manifold-methods-33" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect_voxel(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> fx<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">;</span><span class="dv">8</span>]<span class="op">,</span> level<span class="op">:</span> <span class="dt">Self</span><span class="pp">::</span>Elem) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span>[VoxelEdge<span class="op">;</span><span class="dv">3</span>]<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="manifold-methods-34"><a href="#manifold-methods-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> triangles <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span>[VoxelEdge<span class="op">;</span><span class="dv">3</span>]<span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="manifold-methods-35"><a href="#manifold-methods-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tet <span class="kw">in</span> CUBE_CELLS <span class="op">{</span></span>
<span id="manifold-methods-36"><a href="#manifold-methods-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>intersect_tetrahedron(fx<span class="op">,</span> level<span class="op">,</span> <span class="op">&amp;</span>tet<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> triangles)<span class="op">;</span></span>
<span id="manifold-methods-37"><a href="#manifold-methods-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="manifold-methods-38"><a href="#manifold-methods-38" aria-hidden="true" tabindex="-1"></a>    triangles</span>
<span id="manifold-methods-39"><a href="#manifold-methods-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>Now that we have a set of proto-triangles, we need to convert them into proto-vertices and triangles. The nice thing about a proto-vertex is that we have robust equality, something that we wouldn’t have had had we computed the actual floating-point coordinates of the vertex. Since we have identity, we can do combinatorics. We loop over every proto-triangle, insert their proto-vertices into a map, such that each vertex is assigned a unique integer. We can then convert every proto-triangle into a triple of integers, each pointing to a different vertex.</p>
<div class="annotated-code">
<p><span><em>«level-set-combine»=</em></span></p>
<div class="sourceCode" id="level-set-combine"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="level-set-combine-1"><a href="#level-set-combine-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> proto_vertices <span class="op">=</span> <span class="pp">BTreeMap::</span>new()<span class="op">;</span></span>
<span id="level-set-combine-2"><a href="#level-set-combine-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> triangles <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(proto_triangles<span class="op">.</span>len())<span class="op">;</span></span>
<span id="level-set-combine-3"><a href="#level-set-combine-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> get_index <span class="op">=</span> <span class="op">|</span>edge<span class="op">:</span> ProtoVertex<span class="op">|</span> <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="level-set-combine-4"><a href="#level-set-combine-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> proto_vertices<span class="op">.</span>len()<span class="op">;</span></span>
<span id="level-set-combine-5"><a href="#level-set-combine-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> proto_vertices<span class="op">.</span>contains_key(<span class="op">&amp;</span>edge) <span class="op">{</span></span>
<span id="level-set-combine-6"><a href="#level-set-combine-6" aria-hidden="true" tabindex="-1"></a>        proto_vertices[<span class="op">&amp;</span>edge]</span>
<span id="level-set-combine-7"><a href="#level-set-combine-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="level-set-combine-8"><a href="#level-set-combine-8" aria-hidden="true" tabindex="-1"></a>        proto_vertices<span class="op">.</span>insert(edge<span class="op">,</span> s)<span class="op">;</span></span>
<span id="level-set-combine-9"><a href="#level-set-combine-9" aria-hidden="true" tabindex="-1"></a>        s</span>
<span id="level-set-combine-10"><a href="#level-set-combine-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="level-set-combine-11"><a href="#level-set-combine-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="level-set-combine-12"><a href="#level-set-combine-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="level-set-combine-13"><a href="#level-set-combine-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> [a<span class="op">,</span> b<span class="op">,</span> c] <span class="kw">in</span> proto_triangles <span class="op">{</span></span>
<span id="level-set-combine-14"><a href="#level-set-combine-14" aria-hidden="true" tabindex="-1"></a>    triangles<span class="op">.</span>push([get_index(a)<span class="op">,</span> get_index(b)<span class="op">,</span> get_index(c)])<span class="op">;</span></span>
<span id="level-set-combine-15"><a href="#level-set-combine-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>What is left is to actually compute the more precise coordinates of every vertex.</p>
<div class="annotated-code">
<p><span><em>«level-set-compute»=</em></span></p>
<div class="sourceCode" id="level-set-compute"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="level-set-compute-1"><a href="#level-set-compute-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vertices <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="level-set-compute-2"><a href="#level-set-compute-2" aria-hidden="true" tabindex="-1"></a>vertices<span class="op">.</span>resize(proto_vertices<span class="op">.</span>len()<span class="op">,</span> Vec3([<span class="dv">0</span><span class="op">.,</span><span class="dv">0</span><span class="op">.,</span><span class="dv">0</span><span class="op">.</span>]))<span class="op">;</span></span>
<span id="level-set-compute-3"><a href="#level-set-compute-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ((a<span class="op">,</span> b)<span class="op">,</span> i) <span class="kw">in</span> proto_vertices<span class="op">.</span>iter() <span class="op">{</span></span>
<span id="level-set-compute-4"><a href="#level-set-compute-4" aria-hidden="true" tabindex="-1"></a>    vertices[<span class="op">*</span>i] <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>intersect(<span class="op">*</span>a<span class="op">,</span> <span class="op">*</span>b)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="level-set-compute-5"><a href="#level-set-compute-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="level-set-compute-6"><a href="#level-set-compute-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="level-set-compute-7"><a href="#level-set-compute-7" aria-hidden="true" tabindex="-1"></a>Mesh <span class="op">{</span></span>
<span id="level-set-compute-8"><a href="#level-set-compute-8" aria-hidden="true" tabindex="-1"></a>    triangles<span class="op">:</span> triangles<span class="op">,</span></span>
<span id="level-set-compute-9"><a href="#level-set-compute-9" aria-hidden="true" tabindex="-1"></a>    vertices<span class="op">:</span> vertices</span>
<span id="level-set-compute-10"><a href="#level-set-compute-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h2 id="implementation-of-oracle-on-array3">Implementation of <code>Oracle</code> on <code>Array3</code></h2>
<div class="annotated-code">
<p><span><em>«array-oracle»=</em></span></p>
<div class="sourceCode" id="array-oracle"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="array-oracle-1"><a href="#array-oracle-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>S<span class="op">:</span> Data <span class="op">+</span> RawData<span class="op">&lt;</span>Elem<span class="op">=</span><span class="dt">f64</span><span class="op">&gt;&gt;</span> Oracle <span class="cf">for</span> ArrayBase<span class="op">&lt;</span>S<span class="op">,</span> Ix3<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="array-oracle-2"><a href="#array-oracle-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Elem <span class="op">=</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="array-oracle-3"><a href="#array-oracle-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="array-oracle-4"><a href="#array-oracle-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> grid_shape(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>] <span class="op">{</span></span>
<span id="array-oracle-5"><a href="#array-oracle-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>shape()<span class="op">;</span></span>
<span id="array-oracle-6"><a href="#array-oracle-6" aria-hidden="true" tabindex="-1"></a>        [s[<span class="dv">0</span>]<span class="op">,</span> s[<span class="dv">1</span>]<span class="op">,</span> s[<span class="dv">2</span>]]</span>
<span id="array-oracle-7"><a href="#array-oracle-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="array-oracle-8"><a href="#array-oracle-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> stencil(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> x<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> [<span class="dt">f64</span><span class="op">;</span><span class="dv">8</span>] <span class="op">{</span> </span>
<span id="array-oracle-9"><a href="#array-oracle-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">stencil::</span>flat_2x2x2(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>view()<span class="op">,</span> x)</span>
<span id="array-oracle-10"><a href="#array-oracle-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="array-oracle-11"><a href="#array-oracle-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> intersect(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> b<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Vec3<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="array-oracle-12"><a href="#array-oracle-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y_a <span class="op">=</span> <span class="kw">self</span>[a]<span class="op">;</span></span>
<span id="array-oracle-13"><a href="#array-oracle-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y_b <span class="op">=</span> <span class="kw">self</span>[b]<span class="op">;</span></span>
<span id="array-oracle-14"><a href="#array-oracle-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y_a <span class="op">*</span> y_b <span class="op">&gt;</span> <span class="dv">0.0</span> <span class="op">{</span></span>
<span id="array-oracle-15"><a href="#array-oracle-15" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span></span>
<span id="array-oracle-16"><a href="#array-oracle-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="array-oracle-17"><a href="#array-oracle-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> loc <span class="op">=</span> y_a <span class="op">/</span> (y_a <span class="op">-</span> y_b)<span class="op">;</span></span>
<span id="array-oracle-18"><a href="#array-oracle-18" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(ugrid_pos(a) <span class="op">+</span> grid_pos(make_rel(a<span class="op">,</span> b<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>grid_shape())) <span class="op">*</span> loc)</span>
<span id="array-oracle-19"><a href="#array-oracle-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="array-oracle-20"><a href="#array-oracle-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="array-oracle-21"><a href="#array-oracle-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«marching-tetrahedra-utils»+</em></span></p>
<div class="sourceCode" id="marching-tetrahedra-utils"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="marching-tetrahedra-utils-1"><a href="#marching-tetrahedra-utils-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="marching-tetrahedra-utils-2"><a href="#marching-tetrahedra-utils-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> ugrid_pos(ix<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> Vec3 <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-3"><a href="#marching-tetrahedra-utils-3" aria-hidden="true" tabindex="-1"></a>    Vec3([ix[<span class="dv">0</span>] <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> ix[<span class="dv">1</span>] <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> ix[<span class="dv">2</span>] <span class="kw">as</span> <span class="dt">f64</span>])</span>
<span id="marching-tetrahedra-utils-4"><a href="#marching-tetrahedra-utils-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="marching-tetrahedra-utils-5"><a href="#marching-tetrahedra-utils-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="marching-tetrahedra-utils-6"><a href="#marching-tetrahedra-utils-6" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="marching-tetrahedra-utils-7"><a href="#marching-tetrahedra-utils-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> grid_pos(ix<span class="op">:</span> [<span class="dt">isize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> Vec3 <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-8"><a href="#marching-tetrahedra-utils-8" aria-hidden="true" tabindex="-1"></a>    Vec3([ix[<span class="dv">0</span>] <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> ix[<span class="dv">1</span>] <span class="kw">as</span> <span class="dt">f64</span><span class="op">,</span> ix[<span class="dv">2</span>] <span class="kw">as</span> <span class="dt">f64</span>])</span>
<span id="marching-tetrahedra-utils-9"><a href="#marching-tetrahedra-utils-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="marching-tetrahedra-utils-10"><a href="#marching-tetrahedra-utils-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="marching-tetrahedra-utils-11"><a href="#marching-tetrahedra-utils-11" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="marching-tetrahedra-utils-12"><a href="#marching-tetrahedra-utils-12" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> make_rel(a<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> b<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]<span class="op">,</span> shape<span class="op">:</span> [<span class="dt">usize</span><span class="op">;</span><span class="dv">3</span>]) <span class="op">-&gt;</span> [<span class="dt">isize</span><span class="op">;</span><span class="dv">3</span>] <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-13"><a href="#marching-tetrahedra-utils-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> result<span class="op">:</span> [<span class="dt">isize</span><span class="op">;</span><span class="dv">3</span>] <span class="op">=</span> [<span class="dv">0</span><span class="op">;</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="marching-tetrahedra-utils-14"><a href="#marching-tetrahedra-utils-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">3</span> <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-15"><a href="#marching-tetrahedra-utils-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> d <span class="op">=</span> b[i] <span class="kw">as</span> <span class="dt">isize</span> <span class="op">-</span> a[i] <span class="kw">as</span> <span class="dt">isize</span><span class="op">;</span></span>
<span id="marching-tetrahedra-utils-16"><a href="#marching-tetrahedra-utils-16" aria-hidden="true" tabindex="-1"></a>        result[i] <span class="op">=</span> <span class="cf">if</span> d <span class="op">&lt;</span> <span class="op">-</span>(shape[i] <span class="kw">as</span> <span class="dt">isize</span>)<span class="op">/</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-17"><a href="#marching-tetrahedra-utils-17" aria-hidden="true" tabindex="-1"></a>            d <span class="op">+</span> shape[i] <span class="kw">as</span> <span class="dt">isize</span></span>
<span id="marching-tetrahedra-utils-18"><a href="#marching-tetrahedra-utils-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> d <span class="op">&gt;</span> (shape[i] <span class="kw">as</span> <span class="dt">isize</span>)<span class="op">/</span><span class="dv">2</span> <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-19"><a href="#marching-tetrahedra-utils-19" aria-hidden="true" tabindex="-1"></a>            d <span class="op">-</span> shape[i] <span class="kw">as</span> <span class="dt">isize</span></span>
<span id="marching-tetrahedra-utils-20"><a href="#marching-tetrahedra-utils-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="marching-tetrahedra-utils-21"><a href="#marching-tetrahedra-utils-21" aria-hidden="true" tabindex="-1"></a>            d</span>
<span id="marching-tetrahedra-utils-22"><a href="#marching-tetrahedra-utils-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="marching-tetrahedra-utils-23"><a href="#marching-tetrahedra-utils-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="marching-tetrahedra-utils-24"><a href="#marching-tetrahedra-utils-24" aria-hidden="true" tabindex="-1"></a>    result</span>
<span id="marching-tetrahedra-utils-25"><a href="#marching-tetrahedra-utils-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«array-oracle»+</em></span></p>
<div class="sourceCode" id="array-oracle"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="array-oracle-1"><a href="#array-oracle-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>S<span class="op">:</span> Data <span class="op">+</span> RawData<span class="op">&lt;</span>Elem<span class="op">=</span><span class="dt">f64</span><span class="op">&gt;&gt;</span> Manifold <span class="cf">for</span> ArrayBase<span class="op">&lt;</span>S<span class="op">,</span> Ix3<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="array-oracle-2"><a href="#array-oracle-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> point_inside(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> level<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="array-oracle-3"><a href="#array-oracle-3" aria-hidden="true" tabindex="-1"></a>        y <span class="op">&lt;</span> level</span>
<span id="array-oracle-4"><a href="#array-oracle-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="array-oracle-5"><a href="#array-oracle-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h2 id="non-manifold-surfaces">Non-manifold surfaces</h2>
<p>The classic marching tetrahedra algorithm assumes that the approximated surface is a orientable manifold. This is why it suffices to have an oracle that tells if a given point is inside or outside the set for which we aske the boundary. A more generic case is that of non-manifold surfaces. In that case the surface may have a boundary itself, or in the case of tensor-field topology, we get three <span class="math inline">\(A_3\)</span> surfaces that meet in a <span class="math inline">\(D_4\)</span> line. It is now needed to ask the question: does this given segment intersect the surface?</p>
<div class="annotated-code">
<p><span><em>«non-manifold-trait»=</em></span></p>
<div class="sourceCode" id="non-manifold-trait"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="non-manifold-trait-1"><a href="#non-manifold-trait-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> NonManifold<span class="op">:</span> Oracle <span class="kw">where</span> <span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">:</span> <span class="bu">Clone</span> <span class="op">{</span></span>
<span id="non-manifold-trait-2"><a href="#non-manifold-trait-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> edge_intersects(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> a<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">,</span> b<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span><span class="pp">::</span>Elem) <span class="op">-&gt;</span> <span class="dt">bool</span><span class="op">;</span></span>
<span id="non-manifold-trait-3"><a href="#non-manifold-trait-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>non<span class="op">-</span>manifold<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span>
<span id="non-manifold-trait-4"><a href="#non-manifold-trait-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<p>We could have the case that only one of the edges of a tetrahedron intersects the surface, meaning we would get a surface with a boundary inside that tetrahedron. Depending on the application, these locations may need different treatment.</p>
<p>There are six edges to each tetrahedron, so <span class="math inline">\(2^6 = 64\)</span> possibilities. Only 8 of these cases are to be expected in manifold circumstances.</p>
<div class="annotated-code">
<p><span><em>«non-manifold-methods»=</em></span></p>
<div class="sourceCode" id="non-manifold-methods"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="non-manifold-methods-1"><a href="#non-manifold-methods-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> intersect_tetrahedron(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> fx<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Self</span><span class="pp">::</span>Elem<span class="op">;</span><span class="dv">8</span>]<span class="op">,</span></span>
<span id="non-manifold-methods-2"><a href="#non-manifold-methods-2" aria-hidden="true" tabindex="-1"></a>                         vertices<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">usize</span><span class="op">;</span><span class="dv">4</span>]) <span class="op">-&gt;</span> EdgeCase<span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="non-manifold-methods-3"><a href="#non-manifold-methods-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> tag<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="non-manifold-methods-4"><a href="#non-manifold-methods-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> bit<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="non-manifold-methods-5"><a href="#non-manifold-methods-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="non-manifold-methods-6"><a href="#non-manifold-methods-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 01: 0, 1</span></span>
<span id="non-manifold-methods-7"><a href="#non-manifold-methods-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 02: 0, 2</span></span>
<span id="non-manifold-methods-8"><a href="#non-manifold-methods-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 04: 0, 3</span></span>
<span id="non-manifold-methods-9"><a href="#non-manifold-methods-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 08: 1, 2</span></span>
<span id="non-manifold-methods-10"><a href="#non-manifold-methods-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 0F: 1, 3</span></span>
<span id="non-manifold-methods-11"><a href="#non-manifold-methods-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 10: 2, 3</span></span>
<span id="non-manifold-methods-12"><a href="#non-manifold-methods-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v1 <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="op">{</span></span>
<span id="non-manifold-methods-13"><a href="#non-manifold-methods-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> w1 <span class="op">=</span> vertices[v1]<span class="op">;</span></span>
<span id="non-manifold-methods-14"><a href="#non-manifold-methods-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v2 <span class="kw">in</span> (v1<span class="op">+</span><span class="dv">1</span>)<span class="op">..</span><span class="dv">4</span> <span class="op">{</span></span>
<span id="non-manifold-methods-15"><a href="#non-manifold-methods-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> w2 <span class="op">=</span> vertices[v2]<span class="op">;</span></span>
<span id="non-manifold-methods-16"><a href="#non-manifold-methods-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>edge_intersects(<span class="op">&amp;</span>fx[w1]<span class="op">,</span> <span class="op">&amp;</span>fx[w2]) <span class="op">{</span></span>
<span id="non-manifold-methods-17"><a href="#non-manifold-methods-17" aria-hidden="true" tabindex="-1"></a>                tag <span class="op">&amp;=</span> bit<span class="op">;</span></span>
<span id="non-manifold-methods-18"><a href="#non-manifold-methods-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="non-manifold-methods-19"><a href="#non-manifold-methods-19" aria-hidden="true" tabindex="-1"></a>            bit <span class="op">&lt;&lt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="non-manifold-methods-20"><a href="#non-manifold-methods-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="non-manifold-methods-21"><a href="#non-manifold-methods-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="non-manifold-methods-22"><a href="#non-manifold-methods-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="non-manifold-methods-23"><a href="#non-manifold-methods-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> tag <span class="op">{</span></span>
<span id="non-manifold-methods-24"><a href="#non-manifold-methods-24" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x00</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Empty<span class="op">,</span></span>
<span id="non-manifold-methods-25"><a href="#non-manifold-methods-25" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x01</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-26"><a href="#non-manifold-methods-26" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x02</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-27"><a href="#non-manifold-methods-27" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x03</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-28"><a href="#non-manifold-methods-28" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x04</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-29"><a href="#non-manifold-methods-29" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x05</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-30"><a href="#non-manifold-methods-30" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x06</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-31"><a href="#non-manifold-methods-31" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x07</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Tripod(<span class="dv">0</span><span class="op">,</span> (<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-32"><a href="#non-manifold-methods-32" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x08</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-33"><a href="#non-manifold-methods-33" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x09</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-34"><a href="#non-manifold-methods-34" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0A</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-35"><a href="#non-manifold-methods-35" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0B</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Triangle((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-36"><a href="#non-manifold-methods-36" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0C</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Chopsticks((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> (<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-37"><a href="#non-manifold-methods-37" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0D</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-38"><a href="#non-manifold-methods-38" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0E</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-39"><a href="#non-manifold-methods-39" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x0F</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-40"><a href="#non-manifold-methods-40" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x10</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-41"><a href="#non-manifold-methods-41" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x11</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-42"><a href="#non-manifold-methods-42" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x12</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Chopsticks((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> (<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-43"><a href="#non-manifold-methods-43" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x13</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-44"><a href="#non-manifold-methods-44" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x14</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-45"><a href="#non-manifold-methods-45" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x15</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Triangle((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-46"><a href="#non-manifold-methods-46" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x16</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-47"><a href="#non-manifold-methods-47" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x17</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-48"><a href="#non-manifold-methods-48" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x18</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-49"><a href="#non-manifold-methods-49" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x19</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Tripod(<span class="dv">1</span><span class="op">,</span> (<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-50"><a href="#non-manifold-methods-50" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1A</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-51"><a href="#non-manifold-methods-51" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1B</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-52"><a href="#non-manifold-methods-52" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1C</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-53"><a href="#non-manifold-methods-53" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1D</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-54"><a href="#non-manifold-methods-54" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1E</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Ring(<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-55"><a href="#non-manifold-methods-55" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x1F</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-56"><a href="#non-manifold-methods-56" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x20</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Single((<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-57"><a href="#non-manifold-methods-57" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x21</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Chopsticks((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> (<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-58"><a href="#non-manifold-methods-58" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x22</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-59"><a href="#non-manifold-methods-59" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x23</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-60"><a href="#non-manifold-methods-60" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x24</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-61"><a href="#non-manifold-methods-61" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x25</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-62"><a href="#non-manifold-methods-62" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x26</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Triangle((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-63"><a href="#non-manifold-methods-63" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x27</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-64"><a href="#non-manifold-methods-64" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x28</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-65"><a href="#non-manifold-methods-65" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x29</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-66"><a href="#non-manifold-methods-66" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2A</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Tripod(<span class="dv">2</span><span class="op">,</span> (<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-67"><a href="#non-manifold-methods-67" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2B</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-68"><a href="#non-manifold-methods-68" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2C</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-69"><a href="#non-manifold-methods-69" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2D</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Ring(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-70"><a href="#non-manifold-methods-70" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2E</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-71"><a href="#non-manifold-methods-71" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x2F</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-72"><a href="#non-manifold-methods-72" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x30</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Wedge((<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-73"><a href="#non-manifold-methods-73" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x31</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-74"><a href="#non-manifold-methods-74" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x32</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Zigzag(<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-75"><a href="#non-manifold-methods-75" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x33</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Ring(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-76"><a href="#non-manifold-methods-76" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x34</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Tripod(<span class="dv">3</span><span class="op">,</span> (<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">,</span></span>
<span id="non-manifold-methods-77"><a href="#non-manifold-methods-77" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x35</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-78"><a href="#non-manifold-methods-78" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x36</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-79"><a href="#non-manifold-methods-79" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x37</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-80"><a href="#non-manifold-methods-80" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x38</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Triangle((<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">0</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-81"><a href="#non-manifold-methods-81" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x39</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-82"><a href="#non-manifold-methods-82" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3A</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-83"><a href="#non-manifold-methods-83" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3B</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">0</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-84"><a href="#non-manifold-methods-84" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3C</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Sundial((<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-85"><a href="#non-manifold-methods-85" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3D</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-86"><a href="#non-manifold-methods-86" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3E</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Flap((<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">,</span></span>
<span id="non-manifold-methods-87"><a href="#non-manifold-methods-87" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0x3F</span> <span class="op">=&gt;</span> <span class="pp">EdgeCase::</span>Total<span class="op">,</span></span>
<span id="non-manifold-methods-88"><a href="#non-manifold-methods-88" aria-hidden="true" tabindex="-1"></a>        _    <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Impossible case&quot;</span>)</span>
<span id="non-manifold-methods-89"><a href="#non-manifold-methods-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="non-manifold-methods-90"><a href="#non-manifold-methods-90" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«non-manifold-types»=</em></span></p>
<div class="sourceCode" id="non-manifold-types"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="non-manifold-types-1"><a href="#non-manifold-types-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> EdgeCase<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="non-manifold-types-2"><a href="#non-manifold-types-2" aria-hidden="true" tabindex="-1"></a>    Empty<span class="op">,</span></span>
<span id="non-manifold-types-3"><a href="#non-manifold-types-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>edge<span class="op">-</span>cases<span class="op">&gt;&gt;</span></span>
<span id="non-manifold-types-4"><a href="#non-manifold-types-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<h3 id="cases">Cases</h3>
<figure>
<img src="edge-cases.svg" style="width: 100%; padding: 5pt 15pt 5pt 15pt" alt="Edge cases in non-manifold surface detection" /><figcaption aria-hidden="true">Edge cases in non-manifold surface detection</figcaption>
</figure>
<h4 id="one-edge">One edge</h4>
<p>One edge intersects, we can store this case in a structure <span class="math inline">\(((a, b), c, d)\)</span>, should have a routine that makes a triangle running from a point inside triangle <span class="math inline">\((a, b, c)\)</span>, one in <span class="math inline">\((d, a, b)\)</span> and one on the edge <span class="math inline">\((a,b)\)</span>.</p>
<div class="annotated-code">
<p><span><em>«edge-cases»=</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Single((T<span class="op">,</span> T)<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span>        <span class="co">// Could be ignored</span></span></code></pre></div>
</div>
<h4 id="two-edges">Two edges</h4>
<p>Either we have two edge with a common vertex, forming a wedge:</p>
<p>This case is similar to a single edge, but now we should make two triangles, the outer edge making a quadrilateral area with the tetrahedron.</p>
<p>We may also have two edges without common vertex. This is a degenerate case.</p>
<div class="annotated-code">
<p><span><em>«edge-cases»+</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Wedge((T<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span> T)<span class="op">,</span>         <span class="co">// Could be ignored</span></span>
<span id="edge-cases-2"><a href="#edge-cases-2" aria-hidden="true" tabindex="-1"></a>Chopsticks((T<span class="op">,</span> T)<span class="op">,</span> (T<span class="op">,</span> T))<span class="op">,</span>  <span class="co">// Could be ignored</span></span></code></pre></div>
</div>
<h4 id="three-edges">Three edges</h4>
<div class="annotated-code">
<p><span><em>«edge-cases»+</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Tripod(T<span class="op">,</span> (T<span class="op">,</span> T<span class="op">,</span> T))<span class="op">,</span>        <span class="co">// OK</span></span>
<span id="edge-cases-2"><a href="#edge-cases-2" aria-hidden="true" tabindex="-1"></a>Zigzag(T<span class="op">,</span> T<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span>          <span class="co">// Special but possible</span></span>
<span id="edge-cases-3"><a href="#edge-cases-3" aria-hidden="true" tabindex="-1"></a>Triangle((T<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span> T)<span class="op">,</span>      <span class="co">// Highly problematic</span></span></code></pre></div>
</div>
<h4 id="four-edges">Four edges</h4>
<div class="annotated-code">
<p><span><em>«edge-cases»+</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Ring(T<span class="op">,</span> T<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span>            <span class="co">// OK</span></span>
<span id="edge-cases-2"><a href="#edge-cases-2" aria-hidden="true" tabindex="-1"></a>Sundial((T<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span> T)<span class="op">,</span>       <span class="co">// Tripod + confusion</span></span></code></pre></div>
</div>
<h4 id="five-edges">Five edges</h4>
<div class="annotated-code">
<p><span><em>«edge-cases»+</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Flap((T<span class="op">,</span> T)<span class="op">,</span> T<span class="op">,</span> T)<span class="op">,</span>        <span class="co">// Ring + confusion</span></span></code></pre></div>
</div>
<h4 id="six-edges">Six edges</h4>
<div class="annotated-code">
<p><span><em>«edge-cases»+</em></span></p>
<div class="sourceCode" id="edge-cases"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="edge-cases-1"><a href="#edge-cases-1" aria-hidden="true" tabindex="-1"></a>Total</span></code></pre></div>
</div>
<h3 id="implementation">Implementation</h3>
<div class="annotated-code">
<p><span><em>«non-manifold-methods»+</em></span></p>
<div class="sourceCode" id="non-manifold-methods"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="non-manifold-methods-1"><a href="#non-manifold-methods-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Extracts only Tripod and Ring cases, if you use this on a case that actually</span></span>
<span id="non-manifold-methods-2"><a href="#non-manifold-methods-2" aria-hidden="true" tabindex="-1"></a><span class="co">// yields a closed manifold, other cases should not appear.</span></span>
<span id="non-manifold-methods-3"><a href="#non-manifold-methods-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> free_predicate_set(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> Mesh <span class="op">{</span></span>
<span id="non-manifold-methods-4"><a href="#non-manifold-methods-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::collections::</span>BTreeMap<span class="op">;</span></span>
<span id="non-manifold-methods-5"><a href="#non-manifold-methods-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> proto_triangles <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span>[ProtoVertex<span class="op">;</span><span class="dv">3</span>]<span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="non-manifold-methods-6"><a href="#non-manifold-methods-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="non-manifold-methods-7"><a href="#non-manifold-methods-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ix <span class="kw">in</span> indices(<span class="kw">self</span><span class="op">.</span>grid_shape()) <span class="op">{</span></span>
<span id="non-manifold-methods-8"><a href="#non-manifold-methods-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> index <span class="op">=</span> [ix<span class="op">.</span><span class="dv">0</span><span class="op">,</span> ix<span class="op">.</span><span class="dv">1</span><span class="op">,</span> ix<span class="op">.</span><span class="dv">2</span>]<span class="op">;</span></span>
<span id="non-manifold-methods-9"><a href="#non-manifold-methods-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fx <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>stencil(index)<span class="op">;</span></span>
<span id="non-manifold-methods-10"><a href="#non-manifold-methods-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="non-manifold-methods-11"><a href="#non-manifold-methods-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> tet <span class="kw">in</span> CUBE_CELLS <span class="op">{</span></span>
<span id="non-manifold-methods-12"><a href="#non-manifold-methods-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> push <span class="op">=</span> <span class="op">|</span>(a<span class="op">,</span> b)<span class="op">,</span> (c<span class="op">,</span> d)<span class="op">,</span> (e<span class="op">,</span> f)<span class="op">|</span> <span class="op">{</span></span>
<span id="non-manifold-methods-13"><a href="#non-manifold-methods-13" aria-hidden="true" tabindex="-1"></a>                proto_triangles<span class="op">.</span>push(offset_voxel_edge(<span class="kw">self</span><span class="op">.</span>grid_shape()<span class="op">,</span> index<span class="op">,</span></span>
<span id="non-manifold-methods-14"><a href="#non-manifold-methods-14" aria-hidden="true" tabindex="-1"></a>                    [(tet[a]<span class="op">,</span> tet[b])<span class="op">,</span> (tet[c]<span class="op">,</span> tet[d])<span class="op">,</span> (tet[e]<span class="op">,</span> tet[f])]))</span>
<span id="non-manifold-methods-15"><a href="#non-manifold-methods-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="non-manifold-methods-16"><a href="#non-manifold-methods-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> edge_case <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>intersect_tetrahedron(<span class="op">&amp;</span>fx<span class="op">,</span> <span class="op">&amp;</span>tet)<span class="op">;</span></span>
<span id="non-manifold-methods-17"><a href="#non-manifold-methods-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> edge_case <span class="op">{</span></span>
<span id="non-manifold-methods-18"><a href="#non-manifold-methods-18" aria-hidden="true" tabindex="-1"></a>                <span class="pp">EdgeCase::</span>Tripod(a<span class="op">,</span> (b<span class="op">,</span> c<span class="op">,</span> d)) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="non-manifold-methods-19"><a href="#non-manifold-methods-19" aria-hidden="true" tabindex="-1"></a>                    push((a<span class="op">,</span> b)<span class="op">,</span> (a<span class="op">,</span> c)<span class="op">,</span> (a<span class="op">,</span> d))<span class="op">;</span></span>
<span id="non-manifold-methods-20"><a href="#non-manifold-methods-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="non-manifold-methods-21"><a href="#non-manifold-methods-21" aria-hidden="true" tabindex="-1"></a>                <span class="pp">EdgeCase::</span>Ring(a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> d) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="non-manifold-methods-22"><a href="#non-manifold-methods-22" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> ve1 <span class="op">=</span> offset_voxel_edge(<span class="kw">self</span><span class="op">.</span>grid_shape()<span class="op">,</span> index<span class="op">,</span></span>
<span id="non-manifold-methods-23"><a href="#non-manifold-methods-23" aria-hidden="true" tabindex="-1"></a>                        [(tet[a]<span class="op">,</span> tet[b])<span class="op">,</span> (tet[b]<span class="op">,</span> tet[c])<span class="op">,</span> (tet[c]<span class="op">,</span> tet[d])])<span class="op">;</span></span>
<span id="non-manifold-methods-24"><a href="#non-manifold-methods-24" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> ve2 <span class="op">=</span> offset_voxel_edge(<span class="kw">self</span><span class="op">.</span>grid_shape()<span class="op">,</span> index<span class="op">,</span></span>
<span id="non-manifold-methods-25"><a href="#non-manifold-methods-25" aria-hidden="true" tabindex="-1"></a>                        [(tet[c]<span class="op">,</span> tet[d])<span class="op">,</span> (tet[d]<span class="op">,</span> tet[a])<span class="op">,</span> (tet[a]<span class="op">,</span> tet[b])])<span class="op">;</span></span>
<span id="non-manifold-methods-26"><a href="#non-manifold-methods-26" aria-hidden="true" tabindex="-1"></a>                    proto_triangles<span class="op">.</span>push(ve1)<span class="op">;</span></span>
<span id="non-manifold-methods-27"><a href="#non-manifold-methods-27" aria-hidden="true" tabindex="-1"></a>                    proto_triangles<span class="op">.</span>push(ve2)<span class="op">;</span></span>
<span id="non-manifold-methods-28"><a href="#non-manifold-methods-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="non-manifold-methods-29"><a href="#non-manifold-methods-29" aria-hidden="true" tabindex="-1"></a>                _ <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="non-manifold-methods-30"><a href="#non-manifold-methods-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="non-manifold-methods-31"><a href="#non-manifold-methods-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="non-manifold-methods-32"><a href="#non-manifold-methods-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="non-manifold-methods-33"><a href="#non-manifold-methods-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="non-manifold-methods-34"><a href="#non-manifold-methods-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">-</span>combine<span class="op">&gt;&gt;</span></span>
<span id="non-manifold-methods-35"><a href="#non-manifold-methods-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>level<span class="op">-</span>set<span class="op">-</span>compute<span class="op">&gt;&gt;</span></span>
<span id="non-manifold-methods-36"><a href="#non-manifold-methods-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«src/marching_tetrahedra/mod.rs»=</em></span></p>
<div class="sourceCode" id="cb2" data-file="src/marching_tetrahedra/mod.rs"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="kw">crate</span><span class="pp">::numeric::</span><span class="op">{</span>Vec3<span class="op">};</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="kw">crate</span><span class="pp">::</span>stencil<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// use crate::error::{Error};</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="kw">crate</span><span class="pp">::mesh::</span><span class="op">{</span>Mesh<span class="op">};</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">ndarray::</span><span class="op">{</span>Ix3<span class="op">,</span> indices<span class="op">,</span> Data<span class="op">,</span> RawData<span class="op">,</span> ArrayBase<span class="op">};</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>marching<span class="op">-</span>tetrahedra<span class="op">-</span>types<span class="op">&gt;&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>marching<span class="op">-</span>tetrahedra<span class="op">-</span>utils<span class="op">&gt;&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>cube<span class="op">-</span>decomposition<span class="op">&gt;&gt;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>oracle<span class="op">-</span><span class="kw">trait</span><span class="op">&gt;&gt;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>manifold<span class="op">-</span><span class="kw">trait</span><span class="op">&gt;&gt;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>non<span class="op">-</span>manifold<span class="op">-</span>types<span class="op">&gt;&gt;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>non<span class="op">-</span>manifold<span class="op">-</span><span class="kw">trait</span><span class="op">&gt;&gt;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>array<span class="op">-</span>oracle<span class="op">&gt;&gt;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">pub fn bound_level_set&lt;O1: Oracle, O2: Oracle&gt;(f: &amp;O1, y: f64, g: &amp;O2, z: f64) -&gt; Mesh {</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">    use std::collections::BTreeMap;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">    let mut proto_triangles = Vec::&lt;[ProtoVertex;3]&gt;::new(); // &lt;[ProtoVertex;3]&gt;::new();</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co">    for ix in indices(f.grid_shape()) {</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co">        let index = [ix.0, ix.1, ix.2];</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co">        let gx = g.stencil(index);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co">        if gx.iter().all(|zx| *zx &lt; z) { continue; }</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co">        let fx = f.stencil(index); // stencil::flat_2x2x2(f, index);</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co">        level_set_element(&amp;fx, y).iter().for_each(</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">            |e| proto_triangles.push(offset_edge_tripple(f.grid_shape(), index, *e)));</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co">    }</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co">    let mut proto_vertices = BTreeMap::new();</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">    let mut triangles = Vec::with_capacity(proto_triangles.len());</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">    let mut get_index = |edge: ProtoVertex| -&gt; usize {</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">        let s = proto_vertices.len();</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co">        if proto_vertices.contains_key(&amp;edge) {</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co">            proto_vertices[&amp;edge]</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="co">        } else {</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co">            proto_vertices.insert(edge, s);</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">            s</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">        }</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">        // proto_vertices.try_insert(edge, s).unwrap_or_else(|e| e.value)</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">    };</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co">    for [a, b, c] in proto_triangles {</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="co">        triangles.push([get_index(a), get_index(b), get_index(c)]);</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="co">    }</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="co">    let mut vertices = Vec::new();</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="co">    vertices.resize(proto_vertices.len(), Vec3([0.,0.,0.]));</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co">    for ((a, b), i) in proto_vertices.iter() {</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="co">        vertices[*i] = f.intersect(y, *a, *b).unwrap();</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="co">    }</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="co">    Mesh {</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a><span class="co">        triangles: triangles,</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="co">        vertices: vertices</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="co">    }</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co">}</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test_level_set() <span class="op">{</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">ndarray::</span>arr3<span class="op">;</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> f <span class="op">=</span> arr3(<span class="op">&amp;</span>[[[<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">1</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>]]<span class="op">,</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>                       [[<span class="dv">1</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">2</span><span class="op">.,</span> <span class="dv">4</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">1</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.</span>]]<span class="op">,</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>                       [[<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">1</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">0</span><span class="op">.,</span> <span class="dv">1</span><span class="op">.,</span> <span class="dv">0</span><span class="op">.</span>]]])<span class="op">;</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let m = level_set(&amp;f.view(), 3.0);</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">// m.write_obj_file(&quot;test.obj&quot;);</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>        <span class="co">// println!(&quot;{:?}&quot;, m);</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div></main>



<!-- Bootstrap 4.5.0 -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

<!-- Mathjax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
